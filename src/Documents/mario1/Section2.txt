Paginazione:
L’idea è di dividere la memoria in blocchi tutti di dimensione fissa (tipicamente pochi K) e dividere lo spazio virtuale del processo in pagine tutte della stessa dimensione (uguali ai blocchi fisici)  e l’allocazione della memoria dei processi la si fa per pagine intere anziché per segmenti. Quando mi si chiede di allocare memoria, alloco un blocco intero oppure non lo alloco. Per sapere se un blocco è libero o occupato, non ho più bisogno, come nella segmentazione, di mantenere strutture dati che mi dicono quali sono i frammenti liberi perché posso utilizzare delle Bitmap(strutture dati molto efficienti organizzare come mappe di bit). Ogni bit è associato ad un blocco: 
Se il bit è 1, il blocco è occupato
Se il bit è 0, il blocco è libero
Con la paginazione la memoria virtuale del processo è uno spazio di memoria contiguo che parte dall’indirizzo 0 e arriva fino ad un certo indirizzo massimo, pari al massimo indirizzo rappresentabile. Il processo viene allocato in un certo numero di blocchi di memoria fisica che sono sparpagliati ovunque in memoria principale. Questo fa sorgere un problema: devo sapere dove sono e in che ordine sono, perché se non so queste cosa non posso ricostruire la struttura della memoria del processo. Questa informazione la metto in una struttura dati che si chiama tabella delle pagine. Tramite la tabella delle pagine è possibile ricostruire l’associazione tra pagine virtuali e blocchi fisici che le contengono una tabella delle pagine molto più pesante e complessa della tabella dei segmenti ma ho il grande vantaggio di eliminare la frammentazione esterna e ho la possibilità di poter caricare di un processo solo le pagine che effettivamente gli servono, questo vuol dire che in fase di avvio del processo non devo inizializzare tutta la memoria di quel processo ma posso limitarmi ad inizializzare solo le pagine di cui il processo ha bisogno di utilizzare nella fase iniziale e via via che va avanti alloco le pagine che gli mancano. La traduzione degli indirizzi funziona nel seguente modo:
La CPU genera un indirizzo unico che fa riferimenti allo spazio virtuale (stringa di bit divisa in indice di pagina e offset)
La MMU prende l’indice di pagina e lo utilizza per indicizzare la tabella delle pagine, qui non ho bisogno di alcun meccanismo di protezione perchè il processo ha la possibilità di indicizzare una qualsiasi pagina nel suo spazio virtuale 
Quindi accede alla tabella delle pagine e, dalla riga corrispondente all’indice di pagina, estrae il contenuto, cioè l’indice della pagina fisica
L’indice della pagina fisica viene combinato con l’offset, così da comporre un indirizzo fisico da mandare alla memoria (la composizione equivale, a livello matematico, a moltiplicare la dimensione della pagina per l’indice di pagina fisica per poi sommargli l’offset ma nella pratica si uniscono due flussi di bit)
In generale, quando avviene una commutazione di contesto, si compiono i seguenti passi:
Si deve cambiare il puntatore alla tabella delle pagine, quindi devo salvare il puntatore precedente ed eventualmente anche la dimensione della tabella
Bisogna ripristinare tutti i registri del processo che mandiamo in esecuzione dal PCB ai registri del processore
Bisogna caricare nella MMU l’indice della tabella delle pagine (la tabella delle pagine è grande e sta in memoria principale, l’MMU utilizzerà delle CACHE)
Nel caso le pagine siano molto piccole la dimensione della tabella sarà molto grande, mentre, se sono molto grandi, la dimensione dello spazio non utilizzato aumenta e questo spreco viene detto frammentazione interna (che è comunque un problema più facilmente gestibile rispetto alla frammentazione esterna). In generale la tabella delle pagine deve servire per facilitare i processi, ma se va ad occupare più spazio di quanto ne occupano i processi per fare il loro lavoro, allora non ci siamo. Se voglio far condividere una pagina tra due processi, basta che nella tabella delle pagine di quei due processi faccia puntare lo stesso blocco fisico, quindi in questo modo la pagina resta condivisa, per cui posso implementare, con questo accorgimento, la copy on write. Il meccanismo è quello che segue:
Quando creo il processo figlio duplico la tabella delle pagine (padre e figlio hanno memorie virtuali mappate sulla stessa memoria fisica)
Dopodiché marco tutte le pagine in sola lettura, per cui, non appena il padre o il figlio cercano di scrivere, si solleva un eccezione
A questo punto il SO deve ricordarsi che non è una violazione di protezione, ma un eccezione dovuta alla copy o write e quindi duplica la pagina
N.b. il vantaggio, rispetto alla segmentazione qui è che, nella segmentazione se il figlio vuole modificare un segmento devo duplicare l’intero segmento. Invece nella paginazione, se il figlio vuole modificare solo 1 byte devo copiare solo la pagina che contiene quel byte. in questo modo al copy on write costa meno perché copio meno
Con la paginazione quando creo un nuovo processo posso non allocare niente in memoria, inizializzo la tabella delle pagine marcando tutte le pagine come invalide per cui appena quel processo viene messo in esecuzione genererò un indirizzo, con l’indirizzo andrò ad accedere alla tabella delle pagine, leggerò una pagina che è marcata come invalida e questo scatenerà un eccezione al SO che caricherà quella pagina. Mentre il processo continua la sua esecuzione usando i dati su questa pagina, possiamo caricare le altre pagine che gli stanno intorno. Il vantaggio è che in questo modo del processo carico solo le pagine che effettivamente servono al processo.
Problemi della paginazione: 
Lo spazio virtuale del processo è molto grande e la memoria virtuale viene utilizzata dai processi in maniera sparsa e questo non è controllabile dal SO. Nel momento in cui il processo utilizza poca memoria il risultato che spreco molta memoria per conservare le tabelle delle pagine
La tabella delle pagine non è utilizzata interamente, però la devo allocare per intero, perché il metodo di accesso della tabella delle pagine è quello degli array. Sta in memoria principale.
Soluzioni:
Segmentazione paginata
Tabelle delle pagine multilivello
Segmentazione paginata con tabelle delle pagine multilivello
L’idea di base di questi metodi è di mantenere la dimensione delle pagine piccole, complicare ulteriormente la strutture delle pagine che rappresenta la locazione delle pagine andando a creare delle strutture ad albero. Quest’albero non ha bisogno di essere definito interamente e si sviluppa soltanto per rappresentare le zone di memoria allocate.