Segmentazione paginata:
  Nella segmentazione paginata, lo spazio del processo è segmentato, quindi il processo vede i segmenti. Ne segue che abbiamo una tabella dei segmenti per fare una la traduzione degli indirizzi; la differenza sta nel fatto che il singolo descrittore del segmento non contiene più base-limite ma contiene il puntatore alla tabella delle pagine per quel segmento. Quello che succede, durante la traduzione, è una cosa del genere:
 Genero un indirizzo
L’indirizzo nella prima parte specifica un indice di segmento
Uso questo indice per estrarre, dalla tabella dei segmenti, il descrittore del segmento
Il descrittore del segmento conterrà, a sua volta, la tabella delle pagine associata al segmento
Nella tabella delle pagine troviamo l’indice del blocco fisico sul quale quella pagina è allocata e il bit di protezione
In questo modo combiniamo due aspetti:
Possiamo fare protezione a livello di segmento o a livello di pagina all’interno del segmento
Possiamo fare condivisione a livello di pagina oppure a livello di segmento
Andando a rappresentare la tabella delle pagine per ogni singolo segmento, siccome ogni singolo segmento è più piccolo dello spazio virtuale del processo, il risultato è che la tabella delle pagine per quel segmento sarà più piccola. Non solo, ma i segmenti saranno allocati da un indirizzo iniziale 0 fino ad un certo indirizzo massimo e sono utilizzati in toto perché i segmenti vengono allocati sulla base di una qualche semantica (es. alloco un segmento per il codice e so quanto è grande). Lo spazio virtuale è diviso in segmenti, l’indirizzo generato dal processore è suddiviso in tre campi:
Indice di segmento
Indice di pagina
Offset
Paginazione multilivello:
Può sembrare simile alla segmentazione ma c’è una differenza fondamentale: non c’è più semantica associata ai singoli segmenti. Nella paginazione multilivello, lo spazio virtuale è sempre un unico grande spazio contiguo da 0 fino all’indirizzo massimo, questo spazio viene gestito dal supporto a tempo di esecuzione del linguaggio come pare a lui, quindi allocando informazioni dove gli pare, e da questo segue che sarà naturalmente segmentato ma non perché il sistema fa segmentazione, bensì perché è nella logica di funzione del linguaggio. Quando il processo genera un indirizzo virtuale, questo indirizzo viene visto come diviso in più campi:
Indice di pagina livello 1
Indice di pagina livello 2
Indice di pagine livello 3
.
.
Indice di pagina livello n
Offset
La traduzione funziona nel seguente modo (caso in cui uso 3 livelli di tabelle, per semplicità):
Dal primo campo index indicizzo la tabella delle pagine di primo livello all’interno della quale estraggo un puntatore alla tabella delle pagine di secondo livello
Con quest’ultimo estraggo la tabella di secondo livello che indicizzo con il secondo campo dell’indirizzo e all’interno della quale estraggo un puntatore alla tabella delle pagine di terzo livello
Con quest’ultimo estraggo la tabella di terzo livello che indicizzo con il terzo campo dell’indirizzo virtuale e da questa estraggo il descrittore di pagina che contiene l’indice del blocco fisico
A questo punto lo compongo con l’offset e ottengo l’indirizzo fisico
Il vantaggio del multilivello è che se ho un indirizzo invalido in una tabella di primo livello non ha senso che io allochi una tabella di secondo livello riferita a quell’indirizzo. Quindi risparmio memoria se il processo è piccolo, cosa che non accadeva nel caso della paginazione/segmentazione classica. Nel caso peggiore (quando il processo occupa tutto il suo spazio virtuale) però questo sistema occuperà più memoria perché deve allocare tutto lo spazio del processo, sommato alle varie tabelle di ogni livello. 
N.b. questo modello è utilizzato nelle architetture x86 (2 livelli per segmento)
Vantaggi:
si può allocare e riempire le tabelle delle pagine soltanto quando sono effettivamente necessarie 
la dimensione delle strutture dati è proporzionale alla quantità di memoria che usa il processo 
si può condividere memoria a livello di segmento o a livello di pagina 
si ha un meccanismo di allocazione della memoria molto semplice perché per avere memoria libera basta trovare una pagina libera scorrendo la bitmap 
Svantaggio 
il meccanismo di traduzione degli indirizzi si è complicato enormemente e si sono introdotte diverse complicazioni nella MMU 
In effetti la traduzione degli indirizzi viene fatta tramite una cache che sta dentro l’MMU quindi non carichiamo tutta la tabella delle pagine ma carichiamo solo la cache. Soltanto nel caso in cui l’MMU non sia in grado di tradurre l’indirizzo perché non lo trova nella cache va in memoria principale  ad esplorare la tabella delle pagine per poter fare la traduzione. Ed è in questo caso che si paga di più però se la cache è gestita correttamente questa operazione di traduzione fatta in memoria principale la si fa raramente quindi non incide molto sui costi 
Portabilità:
La scelta del meccanismo di traduzione degli indirizzi e quindi della rappresentazione dello spazio virtuale del processo e della gestione dello spazio fisico è dettata dall’HW, dal processore. Questo vuol dire che se scrivete un SO per un certo processore poi avrete grosse difficoltà a portare quel SO su un altro processore. Se prendete Windows, Linux o iOS questi SO sono portabili su una grande classe di processori, ve li potete trovare su processori tipici da smartphone, desktop etc. Ognuno di questi processori ha la propria architettura, fa le proprie scelte per rappresentare la memoria virtuale e questo vuol dire che ogni volta che vogliamo portare il nostro SO su un’altra piattaforma, su un altro processore, dobbiamo cambiarne il funzionamento interno. Questo non è chiaramente accettabile, l’investimento per sviluppare un SO è enorme e non vogliamo ributtare tutto all’aria e rifare tutto da capo ogni qual volta dobbiamo adattarci ad un nuovo processore. Per questo motivo i SO sono realizzati un po' a “buccia di cipolla”. In particolare, per non dipendere dal meccanismo di gestione della memoria imposto dal processore, e quindi non dipendere dalla tabella delle pagine scelta dal processore con un determinato formato, il SO utilizza una propria tabella delle pagine in qualche modo universale. Il SO rappresenta lo spazio virtuale dei processi utilizzando una propria rappresentazione interna per la tabella delle pagine, per l’allocazione della memoria fisica e quello che si fa quando si porta questo SO da un’architettura all’altra è soltanto modificare i meccanismi di passaggio, di traduzione della tabella dal SO alla tabella imposta dal processore. I SO fano questo per la portabilità e poi lo fanno in quanto devono svolgere tutta una serie di compiti di gestione che vanno al di là della semplice traduzione degli indirizzi. Dal punto di vista del processore è importante tradurre gli indirizzi ma il sistema operativo deve invece occuparsi di caricare i processi in memoria, allocare memoria fisica, stabilire dove allocare un processo, agevolare la condivisione di segmenti e le porzioni di codice e dati. Quindi il SO deve mantenere molte più informazioni di quelle che sono strettamente necessarie al processore per fare la traduzione degli indirizzi. quindi in ogni caso al SO servono strutture aggiuntive (spesso e volentieri tabelle delle pagine inverse). 
Tabella delle Pagine Inversa:
Le tabelle delle pagine inverse spesso si basano su associazioni inverse tra blocco fisico e pagina virtuale. La tabella delle pagine, così com’è usata dal processore, seve per tradurre un indice di pagina virtuale in un indice di pagina fisica, quindi, in qualche modo, il suo utilizzo è unidirezionale e in effetti la tabella delle pagine a livello singolo o quella multilivello sono utilizzate molto bene se si ha come chiave di accesso l’indirizzo virtuale. Però questo fa si che la loro memorizzazione sia un po' dispendiosa, dobbiamo avere una tabella delle pagine per ogni processo quindi spesso ridondanti e poi al SO serve spesso anche l’informazione inversa: dato un blocco fisico vorrei sapere a quale processo quel blocco è allocato perchè devo fare operazioni sui blocchi fisici (trovare blocchi fisici liberi, liberare blocchi fisici quando un processo termina, sapere cosa è allocato su quel blocco, etc..). per questo motivo si usano spesso le tabelle della pagine inverse e ci sono diverse implementazioni:
Sottoforma di tabella hash per cui si usa un hash da una pagina virtuale verso una pagina fisica e in questo modo posso avere un'unica tabella hash per cui si usa un hash per tutti i processi del sistema che ha una dimensione proporzionale alla memoria fisica non più alla memoria virtuale. 
Sottoforma di coremap. Sono strutture alternative che hanno un descrittore per ogni blocco fisico e quel descrittore mi dice qual è la pagina virtuale allocata su quel blocco fisico e a quale processo/i appartiene.
Tenendo presente che il SO deve usare queste strutture dati aggiuntive per rappresentare lo stato di allocazione della memoria fisica etc.. la domanda che sorge è:” abbiamo davvero bisogno delle tabelle delle pagine multilivello?”, di fatto queste tabelle delle pagine devono stare in memoria principale, devono essere mantenute dal SO per permettere al processore di completare la traduzione nel caso in cui, con la cache interna, il processore non possa tradurre l’indirizzo virtuale in indirizzo fisico. Su alcune architetture è stata tentata una strada che adottava questa strategia: la tabella delle pagine era in realtà un hash per cui il processore manteneva nell’MMU una cache della tabella delle pagine per tradurre velocemente gli indirizzi ma nel caso in cui non fosse in grado di farlo tramite questa cache, andava ad accedere a questa tabella hash per andare a caricare il descrittore di pagina all’interno dell’MMU. Attualmente questo tipo di approccio non è utilizzato in quanto gestire una tabella hash ad HW è abbastanza complesso. 
