Translation Lookaside Buffer (TLB):
A livello HW, per la traduzione, non si utilizza la tabella delle pagine memorizzata nell’MMU ma si utilizza un cache. Questa cache si chiama TLB è una memoria abbastanza piccola che mantiene l’associazione tra alcune pagine virtuali e i blocchi fisici sui quali queste pagine sono allocate. Nella TLB non dobbiamo, quindi, conservare tutta la tabella delle pagine del processo ma conserviamo soltanto i descrittori delle pagine che quel processo sta utilizzando in un certo periodo di tempo. Se il processore genera un indirizzo virtuale e questo indirizzo ha una corrispondenza all’interno di questa cache (TLB) vuol dire che esaminandola trovo l’indirizzo di pagina fisica e posso fare immediatamente la traduzione. Questo funziona sia che la tabella delle pagine sia a livello singolo sia che sia multilivello. Questa cache è indipendente dal modello di rappresentazione della tabella delle pagine perché in questa cache sto caricando solo il descrittore di pagina, quindi l’associazione tra la pagina virtuale e la pagina fisica. Se all’interno della TLB non trovo il descrittore della pagina che sto cercando, devo andare a cercarlo in memoria principale esaminando la tabella delle pagine. Se quest’ultima è a livello singolo, faccio un solo accesso alla memoria altrimenti ne faccio di più. Quindi è il processore, nel particolare la MMU, che deve avere la capacità di andare ad esaminare la tabella delle pagine. Il costo della traduzione è dato dal costo di andare a cercare all’interno della TLB (costo piccolo) sommato al costo di andare ad esaminare la tabella delle pagine nel caso in cui ci sia una TLB miss (non riesco a trovare l’associazione nella TLB). La TLB è una tabella che contiene per ogni riga:
Un indice di pagina virtuale 
Un indice di pagina fisica
Diritti di protezione
Nella TLB non ci interessa che ci sia paginazione, segmentazione, uno o più livelli. È assolutamente irrilevante perché siccome l’ultimo livello è quello dato dalla paginazione, noi per tradurre l’indirizzo virtuale dobbiamo soltanto sapere a quale pagina fisica corrisponde. La traduzione procede come segue:
Generato un indirizzo virtuale del processore si estrae l’indice di pagina
Ad HW lo si confronta in maniera parallela con tutti questi campi (la TLB dispone di un numero di  comparatori pari al numero di righe della TLB ed è organizzata in forma associativa):
Se questo confronto da esito positivo vuol dire che la TLB contiene una riga associata a quella pagina virtuale e per quella pagina estrare la pagina fisica (posso tradurla e controllare i diritti di accesso)
Se il confronto da esito negativo vuol dire che la pagina virtuale cercata potrebbe essere presente in memoria principale ma non ho possibilità di tradurla attualmente con le informazioni che sono presenti nella TLB. In questo caso ho un TLB miss quindi devo andare a caricare nella TLB il descrittore della pagina prima di procedere con la traduzione
Potrei anche tentare una strada più semplice: se nella TLB non c’è l’associazione tra pagina virtuale e pagina fisica, potrei sollevare un’eccezione. Metto in esecuzione il SO che a questo punto capisce che qual è la pagina virtuale che ha causato l’eccezione, va lui a scandire la tabella delle pagine e va a caricare il descrittore delle pagine nella TLB. Questo tipo di approccio è stato utilizzato ma non è risultato particolarmente efficiente per il problema della trap al kernel (generare un interruzione verso il kernel che fa partire il SO). Questa operazione porta via centinaia di operazioni che devono essere eseguite dal processore, porta via tempi dell’ordine di centinaia di migliaia di millisecondi mentre se invece lo faccio direttamente dal processore, i tempi sono estremamente più rapidi. 
Super Pagine:
Un’altra caratteristica che si usa spesso nei SO è quella di utilizzare riferimenti a “super pagine”. All’interno della TLB io dovrei conservare un sistema per la traduzione di ogni singolo indirizzo di pagina virtuale però se il SO è stato accorto ha caricato una serie di pagine virtuali consecutive in un insieme di blocchi fisici consecutivi, per tradurre gli indirizzi di tutte queste pagine non ho bisogno di avere una riga nella TLB per ogni pagina ma basta avere una riga collettiva per tutto questo insieme di pagine. In questo modo risparmio spazio nella TLB e sono più efficiente. 
Quando avviene una commutazione di contesto cosa succede alla TLB? Potrei riutilizzare il contenuto della TLB. Quando c’è una commutazione di contesto sappiamo che tolgo un thread dall’esecuzione e ne metto un altro:
Se l’altro thread appartiene ad un altro processo, siccome gli spazi di indirizzamento sono disgiunti, il contenuto della TLB andrà completamente invalidato perché il nuovo thread fa riferimento ad indirizzi che saranno completamente diversi.
Se il thread fa parte dello stesso processo, allora il secondo thread potrebbe utilizzare indirizzi già traducibili con il contenuto della TLB attuale. Quindi invalidare la TLB, in questo caso, non è un vantaggio ma mi conviene tenerla perché il nuovo thread messo in esecuzione riferisce in realtà lo stesso spazio di memoria (fa riferimento alla stessa tabella delle pagine).
Il problema sta nel fatto che se voglio conservare il contenuto della TLB o lo voglio scartare, questo nell’MUU lo devo sapere quindi non mi basta avere le informazioni che ho attualmente nella TLB ma le devo arricchire con informazioni aggiuntive. Per questo motivo nella TLB aggiungo un altro indicatore che è l’indice del processo attualmente in esecuzione.
N.b. non è l’indice del thread, è l’indice del processo perché, sebbene nel SO si mettano in esecuzione i thread e non i processi, tutti i thread dello stesso processo condividono la stessa memoria e la stessa tabella delle pagine. Quindi non mi interessa sapere a quale thread fa riferimento quella riga della TLB ma mi interessa sapere il processo di riferimento.
In questo modo io ho un indicatore che è in realtà un campo e contiene l’identificatore del processo e questo per ogni riga della TLB. Che succede quando il SO decide di cambiare i diritti relativi ad una pagina (fare delle operazioni relative alla gestione delle pagine, cambiare il contenuto della tabella della pagine)? In questi casi, può darsi che quel gestore delle pagine che il SO ha modificato nella tabella delle pagine, abbia una sua copia in una qualche TLB su qualche processore. E questo è un problema perché se quella copia viene utilizzata, non è aggiornata. Quando ci sono queste situazioni, in realtà non si può soltanto modificare la tabella delle pagine ma bisogna avvisare la MMU che va invalidata la TLB o, se si ha un meccanismo più fine, bisogna specificare che certe linee della TLB vanno invalidate. Se siamo su un sistema multicore, per cui ogni core ha la propria TLB, dobbiamo andare a togliere tutte le TLB in cui, potenzialmente, quell’informazione non è più valida. 

Traduzione degli indirizzi con la TLB:
L’indirizzo virtuale va dentro l’MMU, viene confrontato con il contenuto della TLB e si vede se è presente oppure no:
Se l’indirizzo virtuale è presente nella TLB, con le informazioni contenute in quest’ultima, possiamo fare la traduzione e inviamo questo indirizzo in memoria fisica.
Se l’indirizzo non è presente  nella TLB, l’MMU va ad analizzare la tabella delle pagine:
Se nella tabella delle pagine trova il descrittore valido, lo carica nella TLB, fa la traduzione e manda l’indirizzo fisico in memoria principale
Se nella tabella delle pagine trova un descrittore non valido perché, per esempio, quella pagina virtuale non è allocata, allora il processore (l’MMU) non può farci nulla, non può risolvere questa situazione, manda un eccezione al SO e quest’ultimo la gestisce.
È bene notare come il processore non ha solo la TLB ma utilizza anche delle cache per memorizzare i dati, non soltanto per gli indirizzi. quindi la situazione diventa la seguente:
Il processore genera un indirizzo virtuale
Questo indirizzo virtuale viene prima controllato con la cache dati di primissimo livello e si verifica  se a fronte di questo indirizzo virtuale c’è già il dato che può essere prelevato dalla cache:
Se sì, bene
Se no, l’indirizzo virtuale va alla TLB, si cerca di fare la traduzione :
Se si può bene
Se no, si guarda la tabella delle pagine
Se qui non c’è nulla, eccezione
Questo meccanismo in realtà è replicato più e più volte a vari livelli, non lo si fa solo a livello del processore ma lo si fa anche a livello del SO per creare una gerarchia di memoria. In effetti nei sistemi attuali abbiamo una gerarchia di memoria molto profonda. Il meccanismo è sempre quello della cache quindi, la memoria principale, viene vista come una cache di qualcosa memorizzata nel disco, al livello di gestione non è più una cache gestita a primo livello dall’HW. Quindi la traduzione nei processori moderni avviene in modo molto più articolata:
Il processore genera un indirizzo virtuale
Se il dato è nella cache di primo o di secondo livello viene restituito
Altrimenti si manda l’indirizzo alla TLB:
Se si può tradurre, si traduce in indirizzo fisico e a questo punto si va alla cache fisica
Se alla cache fisica si trova il dato si manda al processore
Altrimenti si accede alla memoria principale
Paginazione a Domanda (On-Demand Paging):
il processore, per tradurre gli indirizzi, si aspetta che qualcuno per lui abbia caricato la tabella delle pagine e gli metta a disposizione tutte le informazioni che gli servono. In realtà queste devono essere messe a disposizione dal SO. In tutto questo, il SO può adottare un approccio teorico, ovvero che quando viene creato un processo alloca spazio in memoria fisica, alloca la tabella delle pagine, inizializza la tabella delle pagine per allocare tutto lo spazio virtuale del processo e a questo punto lo mette in esecuzione. In realtà questo non viene mai fatto perché è in larga misura inutile. Il processo non è detto che utilizzi tutte le pagine del suo spazio virtuale a maggior ragione con i processi interattivi in cui le scelte fatte dal processo dipendono dalle scelte fatte dall’utente. Può darsi che alcune istruzioni non vengano utilizzate, alcuni dati non vengano letti, alcuni codici non vengano mai eseguiti. Per questo motivo alcuni SO adottano sistemi di paginazione On-Demand ovvero quando il processo viene generato e viene messo in esecuzione non vengono, in realtà, caricate le pagine del suo spazio virtuale quindi la tabella delle pagine del processo appena generato viene inizializzata per intero come invalida e si lascia che il processo passi in esecuzione, generi degli indirizzi e, a seguito delle eccezioni che vengono fuori perché questi indirizzi corrispondono a pagine non caricate, il SO procede poco alla volta a caricare le pagine che servono a quel processo. Questo permette di mettere in esecuzione molto rapidamente il processo (perché non abbiamo da aspettare che sia caricato il suo spazio virtuale) e abbattere i costi di caricamento nel ciclo di vita completo del processo. Se si usa questa tecnica dobbiamo cambiare un po' la struttura del descrittore di pagina, in particolare il descrittore di pagina è un record che contiene un indice di pagina fisica e poi una serie di indicatori:
Indicatori relativi alla protezione:
Read (R)
Write (W)
Indicatori particolari:
Modified (M)
Used (U)
l bit di presenza: Se la pagina non è presente in memoria il bit di presenza assume il valore 0, altrimenti, se è presente in memoria, allora il suo bit di presenza assume il valore 1.
Il bit di presenza è fondamentale per implementare la paginazione on-demand. Ci sono molti modi di implementarla ma si userà come riferimento quello che segue: 
Nel caso in cui il processo generi un indirizzo di pagina virtuale corrispondente ad una pagina che è caricata, è tutto esattamente come prima. Questo descrittore può essere caricato nella TLB, la TLB può utilizzare l’indice di pagina fisica e può tradurre l’indirizzo. 
Se invece la non è caricata in memoria principale e il bit di presenza è pari a 0 allora vuol dire che se il processore genera questo indirizzo virtuale, l’MMU, usando la TLB, non può tradurre l’indirizzo perchè non sarà presente nel descrittore all’interno della TLB quindi la MMU andrà a cercare il descrittore di pagina all’interno della tabella delle pagine, scoprirà che l’indicatore è pari a 0 e quindi non potrà procedere a caricare questo descrittore all’interno della TLB ma dovrà avvisare il SO che genererà un’eccezione. Il SO, a questo punto, scopre che è stata riferita questa pagina, scopre che non è presente e capisce che se o è una pagina che non è presente ma dovrebbe esserlo e si può caricare, o che è una pagina che non è presente perché non è mai stata allocata e quindi è un errore e si comporta di conseguenza.
Per sapere dove si trova la pagina si può usare il campo dell’indice di pagina fisica che in questo caso codifica uno spazio su disco deve andare a riferire la pagina.   
Gestione fault di pagina:
 Il processore genera un indirizzo virtuale formato da pagina e offset .
Non si può tradurre l’indirizzo perché non è presente questo descrittore di pagina virtuale 
L’MMU a questo punto va nella tabella delle pagine corrispondente e trova il descrittore della pagina ma con codice di presenza pari a 0 
Genera un eccezione verso il processore (page fault) 
Questa eccezione causa l’esecuzione, da parte del SO, di un handler
Quest’ultimo capisce che era in esecuzione il processo PE e il fault è stato generato quando è stato generato un indirizzo della pagina pg
Guarda la tabella delle pagine e si rende conto che questa pagina pg non è caricata in memoria principale ma è caricata in memoria secondaria presente sul disco ad un certo indirizzo
Deve andare a caricarla ma prima deve cercare un blocco fisico libero
A questo punto va ad analizzare la tabella delle pagine inverse che mi dice, per ogni blocco fisico, se è libero o è occupato e se è occupato mi dice quale processo è stato allocato e quale pagina virtuale contiene.
 Andando ad analizzare la coremap, il SO trova un blocco fisico libero e comanda al disco di andare a leggere dall’indirizzo “l” il contenuto della pagina pg e di caricarla in memoria principale  
Fin tanto che questa operazione di copia non si è completata, il SO mette in blocco il thread che ha causato l’eccezione (resta in stato di wait). Manderà in esecuzione degli altri thread, faranno quello che dovranno fare e, quando ad un certo punto questa copia dal disco alla memoria fisica si è completata, il disco lancia un’interruzione al SO, che torna in esecuzione e, capendo che l’operazione si è completata, aggiorna le strutture dati e in particolare va a scrivere nella coremap che la pagina pf è allocata al processo PE e contiene la pagina pg del processo PE.  Fatto questo il thread che ha causato l’eccezione viene messo nello stato di pronto, viene riattivato e, quando tornerà in esecuzione, genererà l’indirizzo <pg,off> causando un’altra volta un TLB miss in quanto non è presente nella TLB, la MMU andrà, quindi, nella tabella delle pagine e stavolta, associato a pg, troverà il valore pf, scoprirà che quella pagina è caricata nel blocco fisico pf, quindi prende l’indice pf e lo combina con l’offset per tradurre l’indirizzo.
